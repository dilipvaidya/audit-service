# audit-service

## Problem Statement
Implement Audit services for a microservices based application.

Audit service is independent distributed service that, as name suggests, helps in auditing the changes made by all the 
other services in their respective resources. Other services generates change notification for the every modify 
operations, acts as producer of the event. Audit service, on the other hand, subscribed to the change notifications, 
acts as a consumers and process the audit messages by writing them into the audit database for future auditing 
capabilities also provided by the audit service. User, based on what audit messages are authorized, can access audit 
service for appropriate audit messages.

### Functional Goal
1. The audit service should subscribe to change notifications from all other services, process and save them into a standard format in the database.
2. Should provide APIs to view audit message, consider two personas for viewing 
   1. Admin who can view all audit messages
   2. Non-admin who can view only for entities he/she has access to
3. Should enable audit log rotation with configurable window.

### Non-functional Goals
1. Format of the audit message
2. Database of choice and schema design with considerations around performance
3. Safeguard against audit tampering
4. Considerations for cross-platform deployment
5. Considerations for capable deployment
6. Develop this service as a Spring Application
7. Deploy as a war in tomcat on a CentOS virtual machine.

## High-level design
### audit service high level design diagram
![AuditService](images/AuditServiceHighLevel.drawio.png)

---

### event broker
Audit Service is independent, highly distributed service that supports the handling of change notifications generated by
producer services. Producer services will generate the notifications into the message broker which audit services are 
subscribed to. There are a couple of options for message brokers to choose from as mentioned below.

### ğŸ“Œ Pros & Cons Summary

#### **Apache Kafka** [selected for this implementation]
- âœ… Pros:
   - High throughput and scalability
   - Built-in durability and re-playability
   - Rich ecosystem (Kafka Streams, KSQL, Connect)
   - Mature in terms of Community, documentation, and long-term support
- âŒ Cons:
   - Operationally complex (ZooKeeper, partitions, brokers)
   - Overkill for simple or low-volume use cases

#### **Apache ActiveMQ**
- âœ… Pros:
   - Simple to set up with JMS support
   - Good for traditional enterprise Java applications
- âŒ Cons:
   - Lower throughput and feature growth compared to Kafka
   - Fewer modern integrations and declining popularity

#### **RabbitMQ**
- âœ… Pros:
   - Lightweight and easy to deploy
   - Excellent support for multiple protocols (AMQP, MQTT)
   - Good plugin ecosystem and UI management
- âŒ Cons:
   - Limited message replay features
   - Throughput lower than Kafka at scale

#### **AWS SQS**
- âœ… Pros:
   - Fully managed, scales automatically
   - No infrastructure or broker management
   - FIFO support and IAM integration
- âŒ Cons:
   - Not open-source or self-hostable
   - No message replay unless explicitly stored elsewhere

#### **ZeroMQ**
- âœ… Pros:
   - Extremely low latency
   - Brokerless and very lightweight
- âŒ Cons:
   - No durability, persistence, or broker management
   - Requires custom implementation for reliability and ordering
   - Not ideal for audit/compliance-grade systems

---

### audit database

#### Available databases options 
1. Elastic search [selected to store data for short duration and real time search queries]
2. MongoDB [not selected]
3. PostgreSQL [selected to store data over longer duration and offline queries]
4. Amazon S3 + athena [not selected]
5. Amazon S3 + Glacier [not selected]

#### ğŸ“Š Audit Log Storage Selection Guide

| Use Case / Criteria                                   | Elasticsearch      | PostgreSQL         | MongoDB            | S3 + Athena        | S3 + Glacier       |
|-------------------------------------------------------|--------------------|--------------------|--------------------|--------------------|--------------------|
| ğŸ” Fast full-text & field-based search (tokenized)    | âœ… Best suited      | âš ï¸ Index-heavy      | âš ï¸ Moderate         | âŒ Not supported    | âŒ Not supported    |
| ğŸ“ˆ High write throughput (real-time logs)             | âœ… Excellent        | âš ï¸ Medium           | âœ… Good             | âš ï¸ Needs batching   | âŒ Not applicable   |
| ğŸ“ Flexible schema / nested fields                    | âœ… Good             | âŒ Rigid            | âœ… Excellent        | âœ… Handles JSON     | âœ… Handles JSON     |
| ğŸ“… Long-term archival (months to years)               | âŒ Costly           | âš ï¸ Medium (with care) | âš ï¸ Costly at scale  | âœ… Cheap            | âœ… Cheapest         |
| ğŸ’¸ Low-cost storage                                    | âŒ High             | âš ï¸ Medium           | âš ï¸ Medium           | âœ… Excellent        | âœ… Excellent        |
| ğŸ“Š Structured reporting & joins                       | âŒ Weak             | âœ… Best suited      | âš ï¸ Limited          | âš ï¸ Complex           | âŒ Not possible     |
| ğŸ” Compliance (immutability, WORM, backups)           | âš ï¸ Needs extensions | âš ï¸ Needs WORM support | âš ï¸ Needs control    | âœ… Versioned        | âœ… WORM by default  |
| ğŸ“‰ Low query frequency (cold access only)             | âŒ Overkill         | âš ï¸ Depends           | âš ï¸ Depends          | âœ… Suited           | âœ… Best suited      |
| ğŸ§  Easy integration with Spring Boot                  | âœ… Spring Data      | âœ… Spring Data JPA  | âœ… Spring Data      | âš ï¸ Via SDK/query layer | âŒ Not direct       |
| ğŸ”„ Data retention, aging, and tiering support         | âœ… ILM policies     | âš ï¸ Manual partition | âš ï¸ Manual           | âœ… Lifecycle rules  | âœ… Auto-tiering     |

Legend:
âœ… = Best suited  
âš ï¸ = Possible with limitations / added effort  
âŒ = Not ideal or unsupported

---

### audit message format

#### ğŸ“ Audit Log Format Design Criteria

| Criterion                         | Description                                                                 | Importance                                                                 |
|----------------------------------|-----------------------------------------------------------------------------|---------------------------------------------------------------------------|
| ğŸ”‘ `eventId`                     | Unique identifier (UUID) for the audit event                                | Ensures traceability and de-duplication                                   |
| ğŸ•’ `timestamp`                   | ISO 8601 formatted timestamp of when the event occurred                     | Critical for ordering and time-range queries                              |
| ğŸ“¦ `sourceService`              | The microservice that generated the event (e.g., user-service)             | Enables filtering and attribution of actions                              |
| ğŸ” `eventType`                  | Type of event (e.g., USER_CREATED, RESOURCE_DELETED)                        | Helps in classification, filtering, and analytics                         |
| ğŸ§© `entityType` & `entityId`    | What was changed (e.g., User, Order) and its ID                             | Core reference to the subject of the change                               |
| ğŸ‘¤ `changedBy`                  | Who made the change â€” includes username, userId, and roles                  | Enables authorization checks and access filtering                         |
| ğŸ”„ `changeSummary`              | What changed â€” structured diff of old vs new values                         | Enables rich history views and auditing fidelity                          |
| ğŸŒ `metadata`                   | Optional context (IP address, user agent, etc.)                             | Useful for forensic, compliance, and security audit trails                |
| ğŸ§  Schema Flexibility           | Support for evolving message structure (e.g., nested, optional fields)     | Important for long-term maintainability and compatibility                 |
| ğŸ” Tamper Evident (optional)    | Signature or hash of message for integrity validation                       | Optional but important for security-sensitive environments                |
| ğŸ’¬ Extensibility                | Should support adding new fields (e.g., tags, severity) over time          | Future-proofing the schema                                                |
| ğŸ” Searchable Field Types       | Field types chosen to support fast and useful searches (e.g., keywords, nested) | Directly impacts performance in Elasticsearch or other search DBs     |





```json
{
   "$schema": "http://json-schema.org/draft-07/schema#",
   "title": "AuditEvent",
   "type": "object",
   "properties": {
      "eventId": {
         "type": "string",
         "format": "uuid"
      },
      "timestamp": {
         "type": "string",
         "format": "date-time/ISO 8601"
      },
      "sourceService": {
         "type": "string"
      },
      "eventType": {
         "type": "string"
      },
      "entityType": {
         "type": "string"
      },
      "entityId": {
         "type": "string"
      },
      "changedBy": {
         "type": "object",
         "properties": {
            "username": { "type": "string" },
            "userId": { "type": "string" },
            "roles": {
               "type": "array",
               "items": { "type": "string" }
            }
         },
         "required": ["username", "userId", "roles"]
      },
      "changeSummary": {
         "type": "object",
         "additionalProperties": {
            "type": "object",
            "properties": {
               "old": { "type": ["string", "null"] },
               "new": { "type": ["string", "null"] }
            },
            "required": ["old", "new"]
         }
      },
      "metadata": {
         "type": "object",
         "properties": {
            "ipAddress": { "type": "string" },
            "userAgent": { "type": "string" }
         },
         "required": ["ipAddress", "userAgent"]
      }
   },
   "required": [
      "eventId",
      "timestamp",
      "sourceService",
      "eventType",
      "entityType",
      "entityId",
      "changedBy",
      "changeSummary",
      "metadata"
   ]
}

```

Example:
```json
{
   "eventId": "uuid",
   "timestamp": "ISO 8601",
   "sourceService": "user-service",
   "eventType": "USER_UPDATED",
   "entityType": "User",
   "entityId": "12345",
   "changedBy": {
      "username": "john.doe",
      "userId": "user-001",
      "roles": ["ADMIN"]
   },
   "changeSummary": {
      "email": {
         "old": "a@example.com",
         "new": "b@example.com"
      }
   },
   "metadata": {
      "ipAddress": "192.168.1.10",
      "userAgent": "Mozilla/5.0"
   }
}

```

another example:
```json
{
   "eventId": "6f8e67ad-8c47-4299-b054-7c87173babc5",
   "timestamp": "2025-05-01T17:00:00Z",
   "sourceService": "library-book-service",
   "eventType": "BOOK_STATUS_CHANGED",
   "entityType": "Book",
   "entityId": "book-456",
   "changedBy": {
      "username": "emma.watson",
      "userId": "staff-789",
      "roles": ["LIBRARIAN"]
   },
   "changeSummary": {
      "status": {
         "old": "available",
         "new": "checked_out"
      }
   },
   "metadata": {
      "ipAddress": "10.0.0.45",
      "userAgent": "Mozilla/5.0"
   }
}

```

elastic search index mapping:
```json
PUT /audit-logs
{
  "mappings": {
    "properties": {
      "eventId": {
        "type": "keyword"
      },
      "timestamp": {
        "type": "date"
      },
      "sourceService": {
        "type": "keyword"
      },
      "eventType": {
        "type": "keyword"
      },
      "entityType": {
        "type": "keyword"
      },
      "entityId": {
        "type": "keyword"
      },
      "changedBy": {
        "properties": {
          "username": { "type": "keyword" },
          "userId": { "type": "keyword" },
          "roles": { "type": "keyword" }
        }
      },
      "changeSummary": {
        "type": "object",
        "dynamic": true
      },
      "metadata": {
        "properties": {
          "ipAddress": { "type": "ip" },
          "userAgent": { "type": "text" }
        }
      }
    }
  }
}
```



### Appendix
Message broker selection criteria comparison

| Criteria                | Meaning                                                                 | Kafka                        | ActiveMQ                    | RabbitMQ                   | AWS SQS                           | ZeroMQ                          |
|------------------------|-------------------------------------------------------------------------|------------------------------|-----------------------------|----------------------------|-----------------------------------|---------------------------------|
| **Durability**         | Ensures messages are not lost                                           | âœ… High (disk + replication) | âœ… Good (persistent queues) | âœ… Good (persistent queues) | âœ… Durable by default              | âŒ Minimal (no persistence)      |
| **Ordering**           | Maintains order of messages                                             | âœ… Per partition              | âš ï¸ Limited                  | âš ï¸ Fair                    | âœ… FIFO queues (optional)         | âš ï¸ App must handle it           |
| **Replayability**      | Ability to reprocess past events                                        | âœ… Yes (offset-based)         | âŒ Not built-in             | âŒ Not built-in            | âŒ Not supported                  | âŒ Manual implementation needed |
| **Throughput**         | Volume of messages per second                                           | ğŸ”¥ Very high                  | âœ… Medium                   | âœ… Medium                  | âœ… Medium to high                 | ğŸ”¥ Extremely high               |
| **Delivery Guarantees**| Exactly-once, at-least-once delivery                                    | âœ… At-least-once (default)    | âœ… At-least-once            | âœ… At-least-once           | âœ… At-least-once or Exactly-once  | âŒ Fire-and-forget mostly       |
| **Latency**            | Time between send and receive                                           | âœ… Low                        | âœ… Low                      | âœ… Low                     | âœ… Low to medium                  | âš¡ Very low                     |
| **Ease of Operations** | Simplicity of setup and maintenance                                     | âš ï¸ Complex (ZK required)      | âœ… Simple                   | âœ… Simple                  | âœ… Fully managed (serverless)     | âš ï¸ DIY                          |
| **Cloud-native**       | Integrates natively with cloud environments                             | âš ï¸ Needs extra setup          | âš ï¸ Manual setup             | âš ï¸ Manual setup            | âœ… Fully managed                  | âŒ Not cloud-native             |
| **Protocol Support**   | Communication protocol support                                          | Kafka protocol               | JMS, STOMP, OpenWire       | AMQP, MQTT, STOMP         | HTTPS + AWS SDK                  | Custom socket-based             |
| **Monitoring Tools**   | Built-in or ecosystem support for visibility                            | âœ… Rich ecosystem             | âœ… Basic tools              | âœ… Good (UI + plugins)     | âœ… CloudWatch + SDK               | âŒ None out of the box          |
| **Maturity**           | Community, documentation, and long-term support                         | âœ… Very mature                | âœ… Mature                   | âœ… Mature                  | âœ… Backed by AWS                  | âš ï¸ Niche, low-level              |

